# PL/SQL

## 记录

语法：

```text
type 名字 is record ( file_declare , file_declare2 ，......) ;
`````

声明变量：

```text
变量名 记录类型 ;
变量名 表或视图%ROWTYPE ; ( 如果写成这个样子，则不再需要声明记录)
```

操作:

- insert ：
- select :
- update :

## 索引表

索引可以为 负值

语法：

```text
type 类型名称 is table of element_type [not null ] index by index_type ; 
```

index_type 类型是 ：binary_integer , pls_integer , varchar2

## 嵌套表

索引从 1 开始，那么 索引就固定了。

如果想要使用 嵌套表，那么必须要 进行初始化（声明长度而已）

语法：

```text
type 类型名称 is table of element_type ;
```

可以通过 下标进行迭代，具体使用方式：

```text
for x in 1..my_qiantao_biao loop 
    -- x 是下标 ， my_qiantao_biao(x) 根据指定的下标获取元素
end loop     
```

## 变长数组

```text
type 类型名称 is varray( max_size ) of element_type ; 
```

指定了 最大长度、同时依旧需要初始化。

## 记录表

```text
1、声明记录
type 记录名称 is record ( column_list )
2、声明 记录类型的 索引表 
type 记录表的名称 is table of 记录类型 index by 索引类型
```

## 批量绑定

- forall
  - forall index in lower..upper sql statement ;
  - forall index values of other_table sql statement ;
  - forall index in indices of other_table sql statement ;

- BULK COLLECT
  - 在select into 中使用

## 游标

- 创建游标：cursor 游标名 is select statement
- 打开游标: open 游标名
- 提取数据 ： 从游标 中 获取 想要的数据
  - fetch 游标名 into 变量 / 记录 ----- 单行
  - fetch 游标名 bulk collect into 集合中
- 关闭游标： close 游标名


- 参数游标：可以在 创建游标的时候指定对应的参数，该参数 是作为 查询的一部分。
- 游标 操作数据（更新、删除） ：
  - 声明游标的时候 指定 for update
  - 使用 where current of 来表示 当前 要 处理的数据行

## 过程

语法：

```text
create or replace procedure 过程名 is PL/SQL块
```

在 创建 过程的时候，可以指定 入参以及出参

```text
create or replace procedure 过程名( 参数1 [model] 类型1.... )
```

model 可以指定 为 in、out、in out ; in 为默认值。

如果一个参数 是 out ，那么需要在 sqlplus 中 定义一个变量，用于接收： var 变量 数据类型

## 函数

## 触发器

## Maven
是Java层面的内容了

maven 是一个 项目管理 工具 与其同名的还有 gradle 、ant（淘汰）

下载：http://maven.apache.org/download.cgi

修改配置：conf/setting.xml

在idea 中进行配置

创建Maven 工程


寻找jar包：https://mvnrepository.com/ ，其实就是一个坐标  

版本 ：

添加jar包：mysql连接java.jar oracle连接java.jar


## JDBC
Java Database Connectivity 

作用：使用 Java 操作 数据库

地位 是 打通了 Java 与 数据库 的桥梁

Java内部定义了一套 接口 （对应的模块是：java.sql），每个数据库 厂商 提供了对应的实现 （ jar包的形式体现出来）

书写JDBC的步骤
1. 加载驱动 ： Class.forName("") ; 
2. 建立连接
3. 书写SQL
4. 获取可以发送SQL 的对象 （Statement）   
4. 将SQL 发送到 数据库
5. 获取结果
6. 关闭资源

### Statement
1、如何 执行 DML( insert、update、delete)、DQL( select )、DDL( create、drop、alter )
2、如何获取结果

- executeUpdate() && executeLargeUpdate() : 可以执行 DML 语句 、DDL 语句 （练习：使用JDBC完成 建表、增删改）
  - 有没有可能执行了DML 语句，返回0 ？ 有可能，例如：delete from table where 1=2 ; 
  - 如何分辨是什么语句呢 ？ DML 语句 或 DDL 语句 ------思考，实践
- executeQuery() : 可以执行 DQL 语句 ,返回一个 ResultSet 结果集
- execute() : 可以执行任意语句 , 返回 boolean 类型的值，true ： 可以获取 ResultSet , false : 可以获取 count 


- 获取自动生成的key : 考虑 底层数据库是否支持 
  - executeUpdate( String SQL , int autoGeneratedKeys) : autoGeneratedKeys 只能是： Statement.RETURN_GENERATED_KEYS 或 Statement.NO_GENERATED_KEYS
  
#### PreparedStatement
预编译并存储SQL ： DML、DDL等

使用：connection.prepareStatement( SQL ) 创建 prepareStatement 对象

使用 preparedStatement.setXXX( int parameterIndex , XXX o ) 设置参数

执行 SQL : executeUpdate 等方法

同时 可以避免 SQL 注入。自己解决 

为了避免 SQL 注入，建议以后都使用 PreparedStatement 。也是 Mybatis 执行SQL 的 首选 

#### CallableStatement
一般是调用 过程 。 { call xxx() } xxx 是过程名 具体参看：CallableStatementTest.java

### ResultSet
结果集 ： 执行 DQL 所产生的结果。

可滚动、可更新的结果集 : PreparedStatement preparedStatement = connection.prepareStatement(SQL , ResultSet.TYPE_SCROLL_SENSITIVE ,  ResultSet.CONCUR_UPDATABLE );

练习：查看 Oracle 是否是 可以进行操作的（ 可滚动、可更新 ）

#### 元数据
描述数据的数据 ： 元数据 . 

ResultSetMetaData ： 结果集的元数据

DatabaseMetaData

### 事务
- 设置事务隔离级别 ： connection.setTransactionIsolation( Connection.TRANSACTION_REPEATABLE_READ);
- 提交事务 ： connection.commit();
- 回滚事务 ： connection.rollback( [savepoint] );
- 是否开启自动提交 : connection.setAutoCommit( false ); 注意：oracle 没有自动提交， mysql 默认自动提交 
- 保存点 ： Savepoint savepoint = connection.setSavepoint( "hahha"); 

### 批量执行
- 将SQL 添加到Statement 对象中 ： addBatch( SQL )
- 执行 ： statement.executeBatch(); || statement.executeLargeBatch(); 需要事务控制。MySQL底层用的是：executeUpdate || executeLargeUpdate() 

- 支持批量插入 ：需要 数据库的语法支持。



### 数据库连接池

C3P0 

Druid

## 类加载
- 类的生命周期
- 类的生命 周期 有几个， 分别干什么 。 
- 类加载器 ： 知道有三个， 可以自己定义即可
- 希望各个 步骤 有所了解


## 反射
- 获取 Class 类型的对象
  - .class 字段
  - Class.forName( String name ) 
  - 对象.getClass() ; 
  
- 可以通过 Class 类型的对象，获取类的一些信息 ： 参看 GetClassInfo.java
  
- 获取 字段  ： Field 类型的对象 ， 获取到的是 修饰符 
- 给字段赋值  
- 获取 方法 ： Method类型的对象， 可以获取 方法名、形参、修饰符、返回类型
- 调用方法  
- 获取 构造 ： Constructor 类型的对象 ， 可以获取形参、修饰符
- 创建实例  
- 获取 内部类 
- 注解
  - 注解是一种标记类型
  - 注解可以写在 方法、接口、类 上
  - @interface 来表示一个 注解类型
  - 如果注解中只有value 属性 需要被指定，那么在指定的时候， value名字可以省略不写( value 仅 被指定 一个值 )
  - 属性的类型只能是 ： 基本数据类型、String、枚举、数组 、Class 、注解 
  
- 元注解
  - @Documented ： 可以让注解 显式在 文档上 
  - @Retention ： 保留多久 
    - RetentionPolicy.CLASS : 保留到 .class 文件中，在运行时丢弃
    - RetentionPolicy.RUNTIME : 保留到 .class 文件中，在运行时保留 
    - RetentionPolicy.SOURCE : 保留在 源代码中，在编译过程中丢弃
  - @Target : 表示可以在那些 类型上使用 
    - values ： ElementType 组成的 数组
    - ElementType 中的 值 自己去看 
  
  - @Repeatable ： 参看 Single 与  Mulita 注解 
  
## NIO
- Charset ： 字符编码
  - 编码 ：把明文的字符序列转换成计算机理解的二进制序列（基本上都看不懂的那种）
  - 解码 ：把 二进制序列 转成 明文 
- Channel ： 通道
- Buffer ： 缓冲
  - 核心 : 0 <= mark <= position <= limit <= capacity
  - mark  : mark = position ， 如果想要做标记，那么 需要让 position 进行移动
  - reset ： position = mark ;  回到 做标记的地方
  - flip ： 锁定：limit = position; position = 0; mark = -1;
  - clear : 重置 ：数据还在 ，position = 0 ; mark = -1 ; limit = capacity ;
  - rewind : 倒带 ：position = 0 , mark= -1;
  - get : 该方法有重载 
    - get() : 读取一个数据 ， 会导致 position ++ ；---> 相对 
    - get( int index ) : 读取指定索引的 数据  -----> 绝对
    - get( byte[] bytes ) ： 读取数据，存放到数组中


## 网络编程
- InetAddress : 表示一个 网络上的地址 
- URLEncoder URLDecoder : 用于在 网络中进行编码/解码
- URL ： 统一资源定位符。就是网址 ： http://www.baidu.com:80 -----》 协议://域名:端口//资源路径
- Socket  : 客户端
  - connect ： 连接一个 服务端 （ServerSocket） 
  - 获取 输入、输出 流
    - socket.getInputStream()  -----> inputStream 
    - socket.getOutputStream() -----> outputStream
- ServerSocket : 充当服务端
  - accept : 接收 一个客户端 
  - bind ： SocketAddress 类型的对象 
    - SocketAddress  中包含： InetAddress port 
  
- DatagramSocket : 可以用来 接收和发送 DatagramPacket 
- DatagramPacket ： 使用 字节 进行 存放数据
  
- 代理 ----> java.net.Proxy

- HttpClient  ： 可以发送请求( request )，并获取响应( response )
  - send( HttpRequest request , BodyHandler handler ) : 发送一个请求，并且描述 响应体如何处理
  
